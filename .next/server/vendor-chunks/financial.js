"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/financial";
exports.ids = ["vendor-chunks/financial"];
exports.modules = {

/***/ "(ssr)/./node_modules/financial/dist/financial.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/financial/dist/financial.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PaymentDueTime: () => (/* binding */ PaymentDueTime),\n/* harmony export */   fv: () => (/* binding */ fv),\n/* harmony export */   ipmt: () => (/* binding */ ipmt),\n/* harmony export */   irr: () => (/* binding */ irr),\n/* harmony export */   mirr: () => (/* binding */ mirr),\n/* harmony export */   nper: () => (/* binding */ nper),\n/* harmony export */   npv: () => (/* binding */ npv),\n/* harmony export */   pmt: () => (/* binding */ pmt),\n/* harmony export */   ppmt: () => (/* binding */ ppmt),\n/* harmony export */   pv: () => (/* binding */ pv),\n/* harmony export */   rate: () => (/* binding */ rate)\n/* harmony export */ });\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * When payments are due\n *\n * @since v0.0.12\n */\nvar PaymentDueTime;\n(function (PaymentDueTime) {\n  /** Payments due at the beginning of a period (1) */\n  PaymentDueTime[\"Begin\"] = \"begin\";\n  /** Payments are due at the end of a period (0) */\n  PaymentDueTime[\"End\"] = \"end\";\n})(PaymentDueTime || (PaymentDueTime = {}));\n/**\n * Compute the future value.\n *\n * @param rate - Rate of interest as decimal (not per cent) per period\n * @param nper - Number of compounding periods\n * @param pmt - A fixed payment, paid either at the beginning or ar the end (specified by `when`)\n * @param pv - Present value\n * @param when - When payment was made\n *\n * @returns The value at the end of the `nper` periods\n *\n * @since v0.0.12\n *\n * ## Examples\n *\n * What is the future value after 10 years of saving $100 now, with\n * an additional monthly savings of $100. Assume the interest rate is\n * 5% (annually) compounded monthly?\n *\n * ```javascript\n * import { fv } from 'financial'\n *\n * fv(0.05 / 12, 10 * 12, -100, -100) // 15692.928894335748\n * ```\n *\n * By convention, the negative sign represents cash flow out (i.e. money not\n * available today).  Thus, saving $100 a month at 5% annual interest leads\n * to $15,692.93 available to spend in 10 years.\n *\n * ## Notes\n *\n * The future value is computed by solving the equation:\n *\n * ```\n * fv + pv * (1+rate) ** nper + pmt * (1 + rate * when) / rate * ((1 + rate) ** nper - 1) == 0\n * ```\n *\n * or, when `rate == 0`:\n *\n * ```\n * fv + pv + pmt * nper == 0\n * ```\n *\n * ## References\n *\n * [Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May)](http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt).\n */\nfunction fv(rate, nper, pmt, pv, when) {\n  if (when === void 0) {\n    when = PaymentDueTime.End;\n  }\n  var isRateZero = rate === 0;\n  if (isRateZero) {\n    return -(pv + pmt * nper);\n  }\n  var temp = Math.pow(1 + rate, nper);\n  var whenMult = when === PaymentDueTime.Begin ? 1 : 0;\n  return -pv * temp - pmt * (1 + rate * whenMult) / rate * (temp - 1);\n}\n/**\n * Compute the payment against loan principal plus interest.\n *\n * @param rate - Rate of interest (per period)\n * @param nper - Number of compounding periods (e.g., number of payments)\n * @param pv - Present value (e.g., an amount borrowed)\n * @param fv - Future value (e.g., 0)\n * @param when - When payments are due\n *\n * @returns the (fixed) periodic payment\n *\n * @since v0.0.12\n *\n * ## Examples\n *\n * What is the monthly payment needed to pay off a $200,000 loan in 15\n * years at an annual interest rate of 7.5%?\n *\n * ```javascript\n * import { pmt } from 'financial'\n *\n * pmt(0.075/12, 12*15, 200000) // -1854.0247200054619\n * ```\n *\n * In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained\n * today, a monthly payment of $1,854.02 would be required.  Note that this\n * example illustrates usage of `fv` having a default value of 0.\n *\n * ## Notes\n *\n * The payment is computed by solving the equation:\n *\n * ```\n * fv + pv * (1 + rate) ** nper + pmt * (1 + rate*when) / rate * ((1 + rate) ** nper - 1) == 0\n * ```\n *\n * or, when `rate == 0`:\n *\n * ```\n * fv + pv + pmt * nper == 0\n * ```\n *\n * for `pmt`.\n *\n * Note that computing a monthly mortgage payment is only\n * one use for this function.  For example, `pmt` returns the\n * periodic deposit one must make to achieve a specified\n * future balance given an initial deposit, a fixed,\n * periodically compounded interest rate, and the total\n * number of periods.\n *\n * ## References\n *\n * [Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May)](http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt).\n */\nfunction pmt(rate, nper, pv, fv, when) {\n  if (fv === void 0) {\n    fv = 0;\n  }\n  if (when === void 0) {\n    when = PaymentDueTime.End;\n  }\n  var isRateZero = rate === 0;\n  var temp = Math.pow(1 + rate, nper);\n  var whenMult = when === PaymentDueTime.Begin ? 1 : 0;\n  var maskedRate = isRateZero ? 1 : rate;\n  var fact = isRateZero ? nper : (1 + maskedRate * whenMult) * (temp - 1) / maskedRate;\n  return -(fv + pv * temp) / fact;\n}\n/**\n * Compute the number of periodic payments.\n *\n * @param rate - Rate of interest (per period)\n * @param pmt - Payment\n * @param pv - Present value\n * @param fv - Future value\n * @param when - When payments are due\n *\n * @returns The number of periodic payments\n *\n * @since v0.0.12\n *\n * ## Examples\n *\n * If you only had $150/month to pay towards the loan, how long would it take\n * to pay-off a loan of $8,000 at 7% annual interest?\n *\n * ```javascript\n * import { nper } from 'financial'\n *\n * Math.round(nper(0.07/12, -150, 8000), 5) // 64.07335\n * ```\n *\n * So, over 64 months would be required to pay off the loan.\n *\n * ## Notes\n *\n * The number of periods `nper` is computed by solving the equation:\n *\n * ```\n * fv + pv * (1+rate) ** nper + pmt * (1+rate * when) / rate * ((1+rate) ** nper-1) = 0\n * ```\n *\n * but if `rate = 0` then:\n *\n * ```\n * fv + pv + pmt * nper = 0\n * ```\n */\nfunction nper(rate, pmt, pv, fv, when) {\n  if (fv === void 0) {\n    fv = 0;\n  }\n  if (when === void 0) {\n    when = PaymentDueTime.End;\n  }\n  var isRateZero = rate === 0;\n  if (isRateZero) {\n    return -(fv + pv) / pmt;\n  }\n  var whenMult = when === PaymentDueTime.Begin ? 1 : 0;\n  var z = pmt * (1 + rate * whenMult) / rate;\n  return Math.log((-fv + z) / (pv + z)) / Math.log(1 + rate);\n}\n/**\n * Compute the interest portion of a payment.\n *\n * @param rate - Rate of interest as decimal (not per cent) per period\n * @param per - Interest paid against the loan changes during the life or the loan. The `per` is the payment period to calculate the interest amount\n * @param nper - Number of compounding periods\n * @param pv - Present value\n * @param fv - Future value\n * @param when - When payments are due\n *\n * @returns Interest portion of payment\n *\n * @since v0.0.12\n *\n * ## Examples\n *\n * What is the amortization schedule for a 1 year loan of $2500 at\n * 8.24% interest per year compounded monthly?\n *\n * ```javascript\n * const principal = 2500\n * const periods = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n * const ipmts = periods.map((per) => f.ipmt(0.0824 / 12, per, 1 * 12, principal))\n * expect(ipmts).toEqual([\n *   -17.166666666666668,\n *   -15.789337457350777,\n *   -14.402550587464257,\n *   -13.006241114404524,\n *   -11.600343649629737,\n *   -10.18479235559687,\n *   -8.759520942678298,\n *   -7.324462666057678,\n *   -5.879550322604295,\n *   -4.424716247725826,\n *   -2.9598923121998877,\n *   -1.4850099189833388\n * ])\n * const interestpd = ipmts.reduce((a, b) => a + b, 0)\n * expect(interestpd).toBeCloseTo(-112.98308424136215, 6)\n * ```\n *\n * The `periods` variable represents the periods of the loan.  Remember that financial equations start the period count at 1!\n *\n * ## Notes\n *\n * The total payment is made up of payment against principal plus interest.\n *\n * ```\n * pmt = ppmt + ipmt\n * ```\n */\nfunction ipmt(rate, per, nper, pv, fv, when) {\n  if (fv === void 0) {\n    fv = 0;\n  }\n  if (when === void 0) {\n    when = PaymentDueTime.End;\n  }\n  // Payments start at the first period, so payments before that\n  // don't make any sense.\n  if (per < 1) {\n    return Number.NaN;\n  }\n  // If payments occur at the beginning of a period and this is the\n  // first period, then no interest has accrued.\n  if (when === PaymentDueTime.Begin && per === 1) {\n    return 0;\n  }\n  var totalPmt = pmt(rate, nper, pv, fv, when);\n  var ipmtVal = _rbl(rate, per, totalPmt, pv, when) * rate;\n  // If paying at the beginning we need to discount by one period\n  if (when === PaymentDueTime.Begin && per > 1) {\n    ipmtVal = ipmtVal / (1 + rate);\n  }\n  return ipmtVal;\n}\n/**\n * Compute the payment against loan principal.\n *\n * @param rate - Rate of interest (per period)\n * @param per - Amount paid against the loan changes.  The `per` is the period of interest.\n * @param nper - Number of compounding periods\n * @param pv - Present value\n * @param fv - Future value\n * @param when - When payments are due\n *\n * @returns the payment against loan principal\n *\n * @since v0.0.14\n */\nfunction ppmt(rate, per, nper, pv, fv, when) {\n  if (fv === void 0) {\n    fv = 0;\n  }\n  if (when === void 0) {\n    when = PaymentDueTime.End;\n  }\n  var total = pmt(rate, nper, pv, fv, when);\n  return total - ipmt(rate, per, nper, pv, fv, when);\n}\n/**\n * Calculates the present value of an annuity investment based on constant-amount\n * periodic payments and a constant interest rate.\n *\n * @param rate - Rate of interest (per period)\n * @param nper - Number of compounding periods\n * @param pmt - Payment\n * @param fv - Future value\n * @param when - When payments are due\n *\n * @returns the present value of a payment or investment\n *\n * @since v0.0.15\n *\n * ## Examples\n *\n * What is the present value (e.g., the initial investment)\n * of an investment that needs to total $15692.93\n * after 10 years of saving $100 every month?  Assume the\n * interest rate is 5% (annually) compounded monthly.\n *\n * ```javascript\n * import { pv } from 'financial'\n *\n * pv(0.05/12, 10*12, -100, 15692.93) // -100.00067131625819\n * ```\n *\n * By convention, the negative sign represents cash flow out\n * (i.e., money not available today).  Thus, to end up with\n * $15,692.93 in 10 years saving $100 a month at 5% annual\n * interest, one's initial deposit should also be $100.\n *\n * ## Notes\n *\n * The present value is computed by solving the equation:\n *\n * ```\n * fv + pv * (1 + rate) ** nper + pmt * (1 + rate * when) / rate * ((1 + rate) ** nper - 1) = 0\n * ```\n *\n * or, when `rate = 0`:\n *\n * ```\n * fv + pv + pmt * nper = 0\n * ```\n *\n * for `pv`, which is then returned.\n *\n * ## References\n *\n * [Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May)](http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt).\n */\nfunction pv(rate, nper, pmt, fv, when) {\n  if (fv === void 0) {\n    fv = 0;\n  }\n  if (when === void 0) {\n    when = PaymentDueTime.End;\n  }\n  var whenMult = when === PaymentDueTime.Begin ? 1 : 0;\n  var isRateZero = rate === 0;\n  var temp = Math.pow(1 + rate, nper);\n  var fact = isRateZero ? nper : (1 + rate * whenMult) * (temp - 1) / rate;\n  return -(fv + pmt * fact) / temp;\n}\n/**\n * Compute the rate of interest per period\n *\n * @param nper - Number of compounding periods\n * @param pmt - Payment\n * @param pv - Present value\n * @param fv - Future value\n * @param when - When payments are due ('begin' or 'end')\n * @param guess - Starting guess for solving the rate of interest\n * @param tol - Required tolerance for the solution\n * @param maxIter - Maximum iterations in finding the solution\n *\n * @returns the rate of interest per period (or `NaN` if it could\n *  not be computed within the number of iterations provided)\n *\n * @since v0.0.16\n *\n * ## Notes\n *\n * Use Newton's iteration until the change is less than 1e-6\n * for all values or a maximum of 100 iterations is reached.\n * Newton's rule is:\n *\n * ```\n * r_{n+1} = r_{n} - g(r_n)/g'(r_n)\n * ```\n *\n * where:\n *\n * - `g(r)` is the formula\n * - `g'(r)` is the derivative with respect to r.\n *\n *\n * The rate of interest is computed by iteratively solving the\n * (non-linear) equation:\n *\n * ```\n * fv + pv * (1+rate) ** nper + pmt * (1+rate * when) / rate * ((1+rate) ** nper - 1) = 0\n * ```\n *\n * for `rate.\n *\n * ## References\n *\n * [Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May)](http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt).\n */\nfunction rate(nper, pmt, pv, fv, when, guess, tol, maxIter) {\n  if (when === void 0) {\n    when = PaymentDueTime.End;\n  }\n  if (guess === void 0) {\n    guess = 0.1;\n  }\n  if (tol === void 0) {\n    tol = 1e-6;\n  }\n  if (maxIter === void 0) {\n    maxIter = 100;\n  }\n  var rn = guess;\n  var iterator = 0;\n  var close = false;\n  while (iterator < maxIter && !close) {\n    var rnp1 = rn - _gDivGp(rn, nper, pmt, pv, fv, when);\n    var diff = Math.abs(rnp1 - rn);\n    close = diff < tol;\n    iterator++;\n    rn = rnp1;\n  }\n  // if exausted all the iterations and the result is not\n  // close enough, returns `NaN`\n  if (!close) {\n    return Number.NaN;\n  }\n  return rn;\n}\n/**\n * Return the Internal Rate of Return (IRR).\n *\n * This is the \"average\" periodically compounded rate of return\n * that gives a net present value of 0.0; for a more complete\n * explanation, see Notes below.\n *\n * @param values - Input cash flows per time period.\n *   By convention, net \"deposits\"\n *   are negative and net \"withdrawals\" are positive.  Thus, for\n *   example, at least the first element of `values`, which represents\n *   the initial investment, will typically be negative.\n * @param guess - Starting guess for solving the Internal Rate of Return\n * @param tol - Required tolerance for the solution\n * @param maxIter - Maximum iterations in finding the solution\n *\n * @returns Internal Rate of Return for periodic input values\n *\n * @since v0.0.17\n *\n * ## Notes\n *\n * The IRR is perhaps best understood through an example (illustrated\n * using `irr` in the Examples section below).\n *\n * Suppose one invests 100\n * units and then makes the following withdrawals at regular (fixed)\n * intervals: 39, 59, 55, 20.  Assuming the ending value is 0, one's 100\n * unit investment yields 173 units; however, due to the combination of\n * compounding and the periodic withdrawals, the \"average\" rate of return\n * is neither simply 0.73/4 nor (1.73)^0.25-1.\n * Rather, it is the solution (for `r`) of the equation:\n *\n * ```\n * -100 + 39/(1+r) + 59/((1+r)^2) + 55/((1+r)^3) + 20/((1+r)^4) = 0\n * ```\n *\n * In general, for `values` = `[0, 1, ... M]`,\n * `irr` is the solution of the equation:\n *\n * ```\n * \\\\sum_{t=0}^M{\\\\frac{v_t}{(1+irr)^{t}}} = 0\n * ```\n *\n * ## Example\n *\n * ```javascript\n * import { irr } from 'financial'\n *\n * irr([-100, 39, 59, 55, 20]) // 0.28095\n * irr([-100, 0, 0, 74]) // -0.0955\n * irr([-100, 100, 0, -7]) // -0.0833\n * irr([-100, 100, 0, 7]) // 0.06206\n * irr([-5, 10.5, 1, -8, 1]) // 0.0886\n * ```\n *\n * ## References\n *\n * - L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n *  Addison-Wesley, 2003, pg. 348.\n */\nfunction irr(values, guess, tol, maxIter) {\n  if (guess === void 0) {\n    guess = 0.1;\n  }\n  if (tol === void 0) {\n    tol = 1e-6;\n  }\n  if (maxIter === void 0) {\n    maxIter = 100;\n  }\n  // Based on https://gist.github.com/ghalimi/4591338 by @ghalimi\n  // ASF licensed (check the link for the full license)\n  // Credits: algorithm inspired by Apache OpenOffice\n  // Initialize dates and check that values contains at\n  // least one positive value and one negative value\n  var dates = [];\n  var positive = false;\n  var negative = false;\n  for (var i = 0; i < values.length; i++) {\n    dates[i] = i === 0 ? 0 : dates[i - 1] + 365;\n    if (values[i] > 0) {\n      positive = true;\n    }\n    if (values[i] < 0) {\n      negative = true;\n    }\n  }\n  // Return error if values does not contain at least one positive\n  // value and one negative value\n  if (!positive || !negative) {\n    return Number.NaN;\n  }\n  // Initialize guess and resultRate\n  var resultRate = guess;\n  // Implement Newton's method\n  var newRate = 0;\n  var epsRate = 0;\n  var resultValue = 0;\n  var iteration = 0;\n  var contLoop = true;\n  do {\n    resultValue = _irrResult(values, dates, resultRate);\n    newRate = resultRate - resultValue / _irrResultDeriv(values, dates, resultRate);\n    epsRate = Math.abs(newRate - resultRate);\n    resultRate = newRate;\n    contLoop = epsRate > tol && Math.abs(resultValue) > tol;\n  } while (contLoop && ++iteration < maxIter);\n  if (contLoop) {\n    return Number.NaN;\n  }\n  // Return internal rate of return\n  return resultRate;\n}\n/**\n * Returns the NPV (Net Present Value) of a cash flow series.\n *\n * @param rate - The discount rate\n * @param values - The values of the time series of cash flows.  The (fixed) time\n * interval between cash flow \"events\" must be the same as that for\n * which `rate` is given (i.e., if `rate` is per year, then precisely\n * a year is understood to elapse between each cash flow event).  By\n * convention, investments or \"deposits\" are negative, income or\n * \"withdrawals\" are positive; `values` must begin with the initial\n * investment, thus `values[0]` will typically be negative.\n * @returns The NPV of the input cash flow series `values` at the discount `rate`.\n *\n * @since v0.0.18\n *\n * ## Warnings\n *\n * `npv considers a series of cashflows starting in the present (t = 0).\n * NPV can also be defined with a series of future cashflows, paid at the\n * end, rather than the start, of each period. If future cashflows are used,\n * the first cashflow `values[0]` must be zeroed and added to the net\n * present value of the future cashflows. This is demonstrated in the\n * examples.\n *\n * ## Notes\n *\n * Returns the result of:\n *\n * ```\n * \\\\sum_{t=0}^{M-1}{\\\\frac{values_t}{(1+rate)^{t}}}\n * ```\n *\n * ## Examples\n *\n * Consider a potential project with an initial investment of $40 000 and\n * projected cashflows of $5 000, $8 000, $12 000 and $30 000 at the end of\n * each period discounted at a rate of 8% per period. To find the project's\n * net present value:\n *\n * ```javascript\n * import {npv} from 'financial'\n *\n * const rate = 0.08\n * const cashflows = [-40_000, 5000, 8000, 12000, 30000]\n * npv(rate, cashflows) // 3065.2226681795255\n * ```\n *\n * It may be preferable to split the projected cashflow into an initial\n * investment and expected future cashflows. In this case, the value of\n * the initial cashflow is zero and the initial investment is later added\n * to the future cashflows net present value:\n *\n * ```javascript\n * const initialCashflow = cashflows[0]\n * cashflows[0] = 0\n *\n * npv(rate, cashflows) + initialCashflow // 3065.2226681795255\n * ```\n *\n * ## References\n *\n * L. J. Gitman, \"Principles of Managerial Finance, Brief,\"\n * 3rd ed., Addison-Wesley, 2003, pg. 346.\n */\nfunction npv(rate, values) {\n  return values.reduce(function (acc, curr, i) {\n    return acc + curr / Math.pow(1 + rate, i);\n  }, 0);\n}\n/**\n * Calculates the Modified Internal Rate of Return.\n *\n * @param values - Cash flows (must contain at least one positive and one negative\n *   value) or nan is returned.  The first value is considered a sunk\n *   cost at time zero.\n * @param financeRate - Interest rate paid on the cash flows\n * @param reinvestRate - Interest rate received on the cash flows upon reinvestment\n *\n * @returns Modified internal rate of return\n *\n * @since v0.1.0\n */\nfunction mirr(values, financeRate, reinvestRate) {\n  var positive = false;\n  var negative = false;\n  for (var _iterator = _createForOfIteratorHelperLoose(values), _step; !(_step = _iterator()).done;) {\n    var value = _step.value;\n    if (value > 0) {\n      positive = true;\n    }\n    if (value < 0) {\n      negative = true;\n    }\n  }\n  // Return error if values does not contain at least one\n  // positive value and one negative value\n  if (!positive || !negative) {\n    return Number.NaN;\n  }\n  var numer = Math.abs(npv(reinvestRate, values.map(function (x) {\n    return x > 0 ? x : 0;\n  })));\n  var denom = Math.abs(npv(financeRate, values.map(function (x) {\n    return x < 0 ? x : 0;\n  })));\n  return Math.pow(numer / denom, 1 / (values.length - 1)) * (1 + reinvestRate) - 1;\n}\n/**\n * This function is here to simply have a different name for the 'fv'\n * function to not interfere with the 'fv' keyword argument within the 'ipmt'\n * function.  It is the 'remaining balance on loan' which might be useful as\n * it's own function, but is easily calculated with the 'fv' function.\n *\n * @private\n */\nfunction _rbl(rate, per, pmt, pv, when) {\n  return fv(rate, per - 1, pmt, pv, when);\n}\n/**\n * Evaluates `g(r_n)/g'(r_n)`, where:\n *\n * ```\n * g = fv + pv * (1+rate) ** nper + pmt * (1+rate * when)/rate * ((1+rate) ** nper - 1)\n * ```\n *\n * @private\n */\nfunction _gDivGp(r, n, p, x, y, when) {\n  var w = when === PaymentDueTime.Begin ? 1 : 0;\n  var t1 = Math.pow(r + 1, n);\n  var t2 = Math.pow(r + 1, n - 1);\n  var g = y + t1 * x + p * (t1 - 1) * (r * w + 1) / r;\n  var gp = n * t2 * x - p * (t1 - 1) * (r * w + 1) / Math.pow(r, 2) + n * p * t2 * (r * w + 1) / r + p * (t1 - 1) * w / r;\n  return g / gp;\n}\n/**\n * Calculates the resulting amount.\n *\n * Based on https://gist.github.com/ghalimi/4591338 by @ghalimi\n * ASF licensed (check the link for the full license)\n *\n * @private\n */\nfunction _irrResult(values, dates, rate) {\n  var r = rate + 1;\n  var result = values[0];\n  for (var i = 1; i < values.length; i++) {\n    result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);\n  }\n  return result;\n}\n/**\n * Calculates the first derivation\n *\n * Based on https://gist.github.com/ghalimi/4591338 by @ghalimi\n * ASF licensed (check the link for the full license)\n *\n * @private\n */\nfunction _irrResultDeriv(values, dates, rate) {\n  var r = rate + 1;\n  var result = 0;\n  for (var i = 1; i < values.length; i++) {\n    var frac = (dates[i] - dates[0]) / 365;\n    result -= frac * values[i] / Math.pow(r, frac + 1);\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=financial.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmluYW5jaWFsL2Rpc3QvZmluYW5jaWFsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUssS0FBSyxHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJLEdBQUcsT0FBTyxLQUFLLFNBQVMsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJLEVBQUUsS0FBSyxPQUFPLFVBQVUsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNEJBQTRCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0U7QUFDL0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YWlsd2luZHVpLXNhbGllbnQvLi9ub2RlX21vZHVsZXMvZmluYW5jaWFsL2Rpc3QvZmluYW5jaWFsLmVzbS5qcz85NjFjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpdCkgbyA9IGl0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuLyoqXG4gKiBXaGVuIHBheW1lbnRzIGFyZSBkdWVcbiAqXG4gKiBAc2luY2UgdjAuMC4xMlxuICovXG52YXIgUGF5bWVudER1ZVRpbWU7XG4oZnVuY3Rpb24gKFBheW1lbnREdWVUaW1lKSB7XG4gIC8qKiBQYXltZW50cyBkdWUgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHBlcmlvZCAoMSkgKi9cbiAgUGF5bWVudER1ZVRpbWVbXCJCZWdpblwiXSA9IFwiYmVnaW5cIjtcbiAgLyoqIFBheW1lbnRzIGFyZSBkdWUgYXQgdGhlIGVuZCBvZiBhIHBlcmlvZCAoMCkgKi9cbiAgUGF5bWVudER1ZVRpbWVbXCJFbmRcIl0gPSBcImVuZFwiO1xufSkoUGF5bWVudER1ZVRpbWUgfHwgKFBheW1lbnREdWVUaW1lID0ge30pKTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgZnV0dXJlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSByYXRlIC0gUmF0ZSBvZiBpbnRlcmVzdCBhcyBkZWNpbWFsIChub3QgcGVyIGNlbnQpIHBlciBwZXJpb2RcbiAqIEBwYXJhbSBucGVyIC0gTnVtYmVyIG9mIGNvbXBvdW5kaW5nIHBlcmlvZHNcbiAqIEBwYXJhbSBwbXQgLSBBIGZpeGVkIHBheW1lbnQsIHBhaWQgZWl0aGVyIGF0IHRoZSBiZWdpbm5pbmcgb3IgYXIgdGhlIGVuZCAoc3BlY2lmaWVkIGJ5IGB3aGVuYClcbiAqIEBwYXJhbSBwdiAtIFByZXNlbnQgdmFsdWVcbiAqIEBwYXJhbSB3aGVuIC0gV2hlbiBwYXltZW50IHdhcyBtYWRlXG4gKlxuICogQHJldHVybnMgVGhlIHZhbHVlIGF0IHRoZSBlbmQgb2YgdGhlIGBucGVyYCBwZXJpb2RzXG4gKlxuICogQHNpbmNlIHYwLjAuMTJcbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIFdoYXQgaXMgdGhlIGZ1dHVyZSB2YWx1ZSBhZnRlciAxMCB5ZWFycyBvZiBzYXZpbmcgJDEwMCBub3csIHdpdGhcbiAqIGFuIGFkZGl0aW9uYWwgbW9udGhseSBzYXZpbmdzIG9mICQxMDAuIEFzc3VtZSB0aGUgaW50ZXJlc3QgcmF0ZSBpc1xuICogNSUgKGFubnVhbGx5KSBjb21wb3VuZGVkIG1vbnRobHk/XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgZnYgfSBmcm9tICdmaW5hbmNpYWwnXG4gKlxuICogZnYoMC4wNSAvIDEyLCAxMCAqIDEyLCAtMTAwLCAtMTAwKSAvLyAxNTY5Mi45Mjg4OTQzMzU3NDhcbiAqIGBgYFxuICpcbiAqIEJ5IGNvbnZlbnRpb24sIHRoZSBuZWdhdGl2ZSBzaWduIHJlcHJlc2VudHMgY2FzaCBmbG93IG91dCAoaS5lLiBtb25leSBub3RcbiAqIGF2YWlsYWJsZSB0b2RheSkuICBUaHVzLCBzYXZpbmcgJDEwMCBhIG1vbnRoIGF0IDUlIGFubnVhbCBpbnRlcmVzdCBsZWFkc1xuICogdG8gJDE1LDY5Mi45MyBhdmFpbGFibGUgdG8gc3BlbmQgaW4gMTAgeWVhcnMuXG4gKlxuICogIyMgTm90ZXNcbiAqXG4gKiBUaGUgZnV0dXJlIHZhbHVlIGlzIGNvbXB1dGVkIGJ5IHNvbHZpbmcgdGhlIGVxdWF0aW9uOlxuICpcbiAqIGBgYFxuICogZnYgKyBwdiAqICgxK3JhdGUpICoqIG5wZXIgKyBwbXQgKiAoMSArIHJhdGUgKiB3aGVuKSAvIHJhdGUgKiAoKDEgKyByYXRlKSAqKiBucGVyIC0gMSkgPT0gMFxuICogYGBgXG4gKlxuICogb3IsIHdoZW4gYHJhdGUgPT0gMGA6XG4gKlxuICogYGBgXG4gKiBmdiArIHB2ICsgcG10ICogbnBlciA9PSAwXG4gKiBgYGBcbiAqXG4gKiAjIyBSZWZlcmVuY2VzXG4gKlxuICogW1doZWVsZXIsIEQuIEEuLCBFLiBSYXRoa2UsIGFuZCBSLiBXZWlyIChFZHMuKSAoMjAwOSwgTWF5KV0oaHR0cDovL3d3dy5vYXNpcy1vcGVuLm9yZy9jb21taXR0ZWVzL2RvY3VtZW50cy5waHA/d2dfYWJicmV2PW9mZmljZS1mb3JtdWxhT3BlbkRvY3VtZW50LWZvcm11bGEtMjAwOTA1MDgub2R0KS5cbiAqL1xuZnVuY3Rpb24gZnYocmF0ZSwgbnBlciwgcG10LCBwdiwgd2hlbikge1xuICBpZiAod2hlbiA9PT0gdm9pZCAwKSB7XG4gICAgd2hlbiA9IFBheW1lbnREdWVUaW1lLkVuZDtcbiAgfVxuICB2YXIgaXNSYXRlWmVybyA9IHJhdGUgPT09IDA7XG4gIGlmIChpc1JhdGVaZXJvKSB7XG4gICAgcmV0dXJuIC0ocHYgKyBwbXQgKiBucGVyKTtcbiAgfVxuICB2YXIgdGVtcCA9IE1hdGgucG93KDEgKyByYXRlLCBucGVyKTtcbiAgdmFyIHdoZW5NdWx0ID0gd2hlbiA9PT0gUGF5bWVudER1ZVRpbWUuQmVnaW4gPyAxIDogMDtcbiAgcmV0dXJuIC1wdiAqIHRlbXAgLSBwbXQgKiAoMSArIHJhdGUgKiB3aGVuTXVsdCkgLyByYXRlICogKHRlbXAgLSAxKTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgcGF5bWVudCBhZ2FpbnN0IGxvYW4gcHJpbmNpcGFsIHBsdXMgaW50ZXJlc3QuXG4gKlxuICogQHBhcmFtIHJhdGUgLSBSYXRlIG9mIGludGVyZXN0IChwZXIgcGVyaW9kKVxuICogQHBhcmFtIG5wZXIgLSBOdW1iZXIgb2YgY29tcG91bmRpbmcgcGVyaW9kcyAoZS5nLiwgbnVtYmVyIG9mIHBheW1lbnRzKVxuICogQHBhcmFtIHB2IC0gUHJlc2VudCB2YWx1ZSAoZS5nLiwgYW4gYW1vdW50IGJvcnJvd2VkKVxuICogQHBhcmFtIGZ2IC0gRnV0dXJlIHZhbHVlIChlLmcuLCAwKVxuICogQHBhcmFtIHdoZW4gLSBXaGVuIHBheW1lbnRzIGFyZSBkdWVcbiAqXG4gKiBAcmV0dXJucyB0aGUgKGZpeGVkKSBwZXJpb2RpYyBwYXltZW50XG4gKlxuICogQHNpbmNlIHYwLjAuMTJcbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIFdoYXQgaXMgdGhlIG1vbnRobHkgcGF5bWVudCBuZWVkZWQgdG8gcGF5IG9mZiBhICQyMDAsMDAwIGxvYW4gaW4gMTVcbiAqIHllYXJzIGF0IGFuIGFubnVhbCBpbnRlcmVzdCByYXRlIG9mIDcuNSU/XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgcG10IH0gZnJvbSAnZmluYW5jaWFsJ1xuICpcbiAqIHBtdCgwLjA3NS8xMiwgMTIqMTUsIDIwMDAwMCkgLy8gLTE4NTQuMDI0NzIwMDA1NDYxOVxuICogYGBgXG4gKlxuICogSW4gb3JkZXIgdG8gcGF5LW9mZiAoaS5lLiwgaGF2ZSBhIGZ1dHVyZS12YWx1ZSBvZiAwKSB0aGUgJDIwMCwwMDAgb2J0YWluZWRcbiAqIHRvZGF5LCBhIG1vbnRobHkgcGF5bWVudCBvZiAkMSw4NTQuMDIgd291bGQgYmUgcmVxdWlyZWQuICBOb3RlIHRoYXQgdGhpc1xuICogZXhhbXBsZSBpbGx1c3RyYXRlcyB1c2FnZSBvZiBgZnZgIGhhdmluZyBhIGRlZmF1bHQgdmFsdWUgb2YgMC5cbiAqXG4gKiAjIyBOb3Rlc1xuICpcbiAqIFRoZSBwYXltZW50IGlzIGNvbXB1dGVkIGJ5IHNvbHZpbmcgdGhlIGVxdWF0aW9uOlxuICpcbiAqIGBgYFxuICogZnYgKyBwdiAqICgxICsgcmF0ZSkgKiogbnBlciArIHBtdCAqICgxICsgcmF0ZSp3aGVuKSAvIHJhdGUgKiAoKDEgKyByYXRlKSAqKiBucGVyIC0gMSkgPT0gMFxuICogYGBgXG4gKlxuICogb3IsIHdoZW4gYHJhdGUgPT0gMGA6XG4gKlxuICogYGBgXG4gKiBmdiArIHB2ICsgcG10ICogbnBlciA9PSAwXG4gKiBgYGBcbiAqXG4gKiBmb3IgYHBtdGAuXG4gKlxuICogTm90ZSB0aGF0IGNvbXB1dGluZyBhIG1vbnRobHkgbW9ydGdhZ2UgcGF5bWVudCBpcyBvbmx5XG4gKiBvbmUgdXNlIGZvciB0aGlzIGZ1bmN0aW9uLiAgRm9yIGV4YW1wbGUsIGBwbXRgIHJldHVybnMgdGhlXG4gKiBwZXJpb2RpYyBkZXBvc2l0IG9uZSBtdXN0IG1ha2UgdG8gYWNoaWV2ZSBhIHNwZWNpZmllZFxuICogZnV0dXJlIGJhbGFuY2UgZ2l2ZW4gYW4gaW5pdGlhbCBkZXBvc2l0LCBhIGZpeGVkLFxuICogcGVyaW9kaWNhbGx5IGNvbXBvdW5kZWQgaW50ZXJlc3QgcmF0ZSwgYW5kIHRoZSB0b3RhbFxuICogbnVtYmVyIG9mIHBlcmlvZHMuXG4gKlxuICogIyMgUmVmZXJlbmNlc1xuICpcbiAqIFtXaGVlbGVyLCBELiBBLiwgRS4gUmF0aGtlLCBhbmQgUi4gV2VpciAoRWRzLikgKDIwMDksIE1heSldKGh0dHA6Ly93d3cub2FzaXMtb3Blbi5vcmcvY29tbWl0dGVlcy9kb2N1bWVudHMucGhwP3dnX2FiYnJldj1vZmZpY2UtZm9ybXVsYU9wZW5Eb2N1bWVudC1mb3JtdWxhLTIwMDkwNTA4Lm9kdCkuXG4gKi9cbmZ1bmN0aW9uIHBtdChyYXRlLCBucGVyLCBwdiwgZnYsIHdoZW4pIHtcbiAgaWYgKGZ2ID09PSB2b2lkIDApIHtcbiAgICBmdiA9IDA7XG4gIH1cbiAgaWYgKHdoZW4gPT09IHZvaWQgMCkge1xuICAgIHdoZW4gPSBQYXltZW50RHVlVGltZS5FbmQ7XG4gIH1cbiAgdmFyIGlzUmF0ZVplcm8gPSByYXRlID09PSAwO1xuICB2YXIgdGVtcCA9IE1hdGgucG93KDEgKyByYXRlLCBucGVyKTtcbiAgdmFyIHdoZW5NdWx0ID0gd2hlbiA9PT0gUGF5bWVudER1ZVRpbWUuQmVnaW4gPyAxIDogMDtcbiAgdmFyIG1hc2tlZFJhdGUgPSBpc1JhdGVaZXJvID8gMSA6IHJhdGU7XG4gIHZhciBmYWN0ID0gaXNSYXRlWmVybyA/IG5wZXIgOiAoMSArIG1hc2tlZFJhdGUgKiB3aGVuTXVsdCkgKiAodGVtcCAtIDEpIC8gbWFza2VkUmF0ZTtcbiAgcmV0dXJuIC0oZnYgKyBwdiAqIHRlbXApIC8gZmFjdDtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHBlcmlvZGljIHBheW1lbnRzLlxuICpcbiAqIEBwYXJhbSByYXRlIC0gUmF0ZSBvZiBpbnRlcmVzdCAocGVyIHBlcmlvZClcbiAqIEBwYXJhbSBwbXQgLSBQYXltZW50XG4gKiBAcGFyYW0gcHYgLSBQcmVzZW50IHZhbHVlXG4gKiBAcGFyYW0gZnYgLSBGdXR1cmUgdmFsdWVcbiAqIEBwYXJhbSB3aGVuIC0gV2hlbiBwYXltZW50cyBhcmUgZHVlXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBwZXJpb2RpYyBwYXltZW50c1xuICpcbiAqIEBzaW5jZSB2MC4wLjEyXG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBJZiB5b3Ugb25seSBoYWQgJDE1MC9tb250aCB0byBwYXkgdG93YXJkcyB0aGUgbG9hbiwgaG93IGxvbmcgd291bGQgaXQgdGFrZVxuICogdG8gcGF5LW9mZiBhIGxvYW4gb2YgJDgsMDAwIGF0IDclIGFubnVhbCBpbnRlcmVzdD9cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBucGVyIH0gZnJvbSAnZmluYW5jaWFsJ1xuICpcbiAqIE1hdGgucm91bmQobnBlcigwLjA3LzEyLCAtMTUwLCA4MDAwKSwgNSkgLy8gNjQuMDczMzVcbiAqIGBgYFxuICpcbiAqIFNvLCBvdmVyIDY0IG1vbnRocyB3b3VsZCBiZSByZXF1aXJlZCB0byBwYXkgb2ZmIHRoZSBsb2FuLlxuICpcbiAqICMjIE5vdGVzXG4gKlxuICogVGhlIG51bWJlciBvZiBwZXJpb2RzIGBucGVyYCBpcyBjb21wdXRlZCBieSBzb2x2aW5nIHRoZSBlcXVhdGlvbjpcbiAqXG4gKiBgYGBcbiAqIGZ2ICsgcHYgKiAoMStyYXRlKSAqKiBucGVyICsgcG10ICogKDErcmF0ZSAqIHdoZW4pIC8gcmF0ZSAqICgoMStyYXRlKSAqKiBucGVyLTEpID0gMFxuICogYGBgXG4gKlxuICogYnV0IGlmIGByYXRlID0gMGAgdGhlbjpcbiAqXG4gKiBgYGBcbiAqIGZ2ICsgcHYgKyBwbXQgKiBucGVyID0gMFxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIG5wZXIocmF0ZSwgcG10LCBwdiwgZnYsIHdoZW4pIHtcbiAgaWYgKGZ2ID09PSB2b2lkIDApIHtcbiAgICBmdiA9IDA7XG4gIH1cbiAgaWYgKHdoZW4gPT09IHZvaWQgMCkge1xuICAgIHdoZW4gPSBQYXltZW50RHVlVGltZS5FbmQ7XG4gIH1cbiAgdmFyIGlzUmF0ZVplcm8gPSByYXRlID09PSAwO1xuICBpZiAoaXNSYXRlWmVybykge1xuICAgIHJldHVybiAtKGZ2ICsgcHYpIC8gcG10O1xuICB9XG4gIHZhciB3aGVuTXVsdCA9IHdoZW4gPT09IFBheW1lbnREdWVUaW1lLkJlZ2luID8gMSA6IDA7XG4gIHZhciB6ID0gcG10ICogKDEgKyByYXRlICogd2hlbk11bHQpIC8gcmF0ZTtcbiAgcmV0dXJuIE1hdGgubG9nKCgtZnYgKyB6KSAvIChwdiArIHopKSAvIE1hdGgubG9nKDEgKyByYXRlKTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJlc3QgcG9ydGlvbiBvZiBhIHBheW1lbnQuXG4gKlxuICogQHBhcmFtIHJhdGUgLSBSYXRlIG9mIGludGVyZXN0IGFzIGRlY2ltYWwgKG5vdCBwZXIgY2VudCkgcGVyIHBlcmlvZFxuICogQHBhcmFtIHBlciAtIEludGVyZXN0IHBhaWQgYWdhaW5zdCB0aGUgbG9hbiBjaGFuZ2VzIGR1cmluZyB0aGUgbGlmZSBvciB0aGUgbG9hbi4gVGhlIGBwZXJgIGlzIHRoZSBwYXltZW50IHBlcmlvZCB0byBjYWxjdWxhdGUgdGhlIGludGVyZXN0IGFtb3VudFxuICogQHBhcmFtIG5wZXIgLSBOdW1iZXIgb2YgY29tcG91bmRpbmcgcGVyaW9kc1xuICogQHBhcmFtIHB2IC0gUHJlc2VudCB2YWx1ZVxuICogQHBhcmFtIGZ2IC0gRnV0dXJlIHZhbHVlXG4gKiBAcGFyYW0gd2hlbiAtIFdoZW4gcGF5bWVudHMgYXJlIGR1ZVxuICpcbiAqIEByZXR1cm5zIEludGVyZXN0IHBvcnRpb24gb2YgcGF5bWVudFxuICpcbiAqIEBzaW5jZSB2MC4wLjEyXG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBXaGF0IGlzIHRoZSBhbW9ydGl6YXRpb24gc2NoZWR1bGUgZm9yIGEgMSB5ZWFyIGxvYW4gb2YgJDI1MDAgYXRcbiAqIDguMjQlIGludGVyZXN0IHBlciB5ZWFyIGNvbXBvdW5kZWQgbW9udGhseT9cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwcmluY2lwYWwgPSAyNTAwXG4gKiBjb25zdCBwZXJpb2RzID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTJdXG4gKiBjb25zdCBpcG10cyA9IHBlcmlvZHMubWFwKChwZXIpID0+IGYuaXBtdCgwLjA4MjQgLyAxMiwgcGVyLCAxICogMTIsIHByaW5jaXBhbCkpXG4gKiBleHBlY3QoaXBtdHMpLnRvRXF1YWwoW1xuICogICAtMTcuMTY2NjY2NjY2NjY2NjY4LFxuICogICAtMTUuNzg5MzM3NDU3MzUwNzc3LFxuICogICAtMTQuNDAyNTUwNTg3NDY0MjU3LFxuICogICAtMTMuMDA2MjQxMTE0NDA0NTI0LFxuICogICAtMTEuNjAwMzQzNjQ5NjI5NzM3LFxuICogICAtMTAuMTg0NzkyMzU1NTk2ODcsXG4gKiAgIC04Ljc1OTUyMDk0MjY3ODI5OCxcbiAqICAgLTcuMzI0NDYyNjY2MDU3Njc4LFxuICogICAtNS44Nzk1NTAzMjI2MDQyOTUsXG4gKiAgIC00LjQyNDcxNjI0NzcyNTgyNixcbiAqICAgLTIuOTU5ODkyMzEyMTk5ODg3NyxcbiAqICAgLTEuNDg1MDA5OTE4OTgzMzM4OFxuICogXSlcbiAqIGNvbnN0IGludGVyZXN0cGQgPSBpcG10cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKVxuICogZXhwZWN0KGludGVyZXN0cGQpLnRvQmVDbG9zZVRvKC0xMTIuOTgzMDg0MjQxMzYyMTUsIDYpXG4gKiBgYGBcbiAqXG4gKiBUaGUgYHBlcmlvZHNgIHZhcmlhYmxlIHJlcHJlc2VudHMgdGhlIHBlcmlvZHMgb2YgdGhlIGxvYW4uICBSZW1lbWJlciB0aGF0IGZpbmFuY2lhbCBlcXVhdGlvbnMgc3RhcnQgdGhlIHBlcmlvZCBjb3VudCBhdCAxIVxuICpcbiAqICMjIE5vdGVzXG4gKlxuICogVGhlIHRvdGFsIHBheW1lbnQgaXMgbWFkZSB1cCBvZiBwYXltZW50IGFnYWluc3QgcHJpbmNpcGFsIHBsdXMgaW50ZXJlc3QuXG4gKlxuICogYGBgXG4gKiBwbXQgPSBwcG10ICsgaXBtdFxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGlwbXQocmF0ZSwgcGVyLCBucGVyLCBwdiwgZnYsIHdoZW4pIHtcbiAgaWYgKGZ2ID09PSB2b2lkIDApIHtcbiAgICBmdiA9IDA7XG4gIH1cbiAgaWYgKHdoZW4gPT09IHZvaWQgMCkge1xuICAgIHdoZW4gPSBQYXltZW50RHVlVGltZS5FbmQ7XG4gIH1cbiAgLy8gUGF5bWVudHMgc3RhcnQgYXQgdGhlIGZpcnN0IHBlcmlvZCwgc28gcGF5bWVudHMgYmVmb3JlIHRoYXRcbiAgLy8gZG9uJ3QgbWFrZSBhbnkgc2Vuc2UuXG4gIGlmIChwZXIgPCAxKSB7XG4gICAgcmV0dXJuIE51bWJlci5OYU47XG4gIH1cbiAgLy8gSWYgcGF5bWVudHMgb2NjdXIgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHBlcmlvZCBhbmQgdGhpcyBpcyB0aGVcbiAgLy8gZmlyc3QgcGVyaW9kLCB0aGVuIG5vIGludGVyZXN0IGhhcyBhY2NydWVkLlxuICBpZiAod2hlbiA9PT0gUGF5bWVudER1ZVRpbWUuQmVnaW4gJiYgcGVyID09PSAxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHRvdGFsUG10ID0gcG10KHJhdGUsIG5wZXIsIHB2LCBmdiwgd2hlbik7XG4gIHZhciBpcG10VmFsID0gX3JibChyYXRlLCBwZXIsIHRvdGFsUG10LCBwdiwgd2hlbikgKiByYXRlO1xuICAvLyBJZiBwYXlpbmcgYXQgdGhlIGJlZ2lubmluZyB3ZSBuZWVkIHRvIGRpc2NvdW50IGJ5IG9uZSBwZXJpb2RcbiAgaWYgKHdoZW4gPT09IFBheW1lbnREdWVUaW1lLkJlZ2luICYmIHBlciA+IDEpIHtcbiAgICBpcG10VmFsID0gaXBtdFZhbCAvICgxICsgcmF0ZSk7XG4gIH1cbiAgcmV0dXJuIGlwbXRWYWw7XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIHBheW1lbnQgYWdhaW5zdCBsb2FuIHByaW5jaXBhbC5cbiAqXG4gKiBAcGFyYW0gcmF0ZSAtIFJhdGUgb2YgaW50ZXJlc3QgKHBlciBwZXJpb2QpXG4gKiBAcGFyYW0gcGVyIC0gQW1vdW50IHBhaWQgYWdhaW5zdCB0aGUgbG9hbiBjaGFuZ2VzLiAgVGhlIGBwZXJgIGlzIHRoZSBwZXJpb2Qgb2YgaW50ZXJlc3QuXG4gKiBAcGFyYW0gbnBlciAtIE51bWJlciBvZiBjb21wb3VuZGluZyBwZXJpb2RzXG4gKiBAcGFyYW0gcHYgLSBQcmVzZW50IHZhbHVlXG4gKiBAcGFyYW0gZnYgLSBGdXR1cmUgdmFsdWVcbiAqIEBwYXJhbSB3aGVuIC0gV2hlbiBwYXltZW50cyBhcmUgZHVlXG4gKlxuICogQHJldHVybnMgdGhlIHBheW1lbnQgYWdhaW5zdCBsb2FuIHByaW5jaXBhbFxuICpcbiAqIEBzaW5jZSB2MC4wLjE0XG4gKi9cbmZ1bmN0aW9uIHBwbXQocmF0ZSwgcGVyLCBucGVyLCBwdiwgZnYsIHdoZW4pIHtcbiAgaWYgKGZ2ID09PSB2b2lkIDApIHtcbiAgICBmdiA9IDA7XG4gIH1cbiAgaWYgKHdoZW4gPT09IHZvaWQgMCkge1xuICAgIHdoZW4gPSBQYXltZW50RHVlVGltZS5FbmQ7XG4gIH1cbiAgdmFyIHRvdGFsID0gcG10KHJhdGUsIG5wZXIsIHB2LCBmdiwgd2hlbik7XG4gIHJldHVybiB0b3RhbCAtIGlwbXQocmF0ZSwgcGVyLCBucGVyLCBwdiwgZnYsIHdoZW4pO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwcmVzZW50IHZhbHVlIG9mIGFuIGFubnVpdHkgaW52ZXN0bWVudCBiYXNlZCBvbiBjb25zdGFudC1hbW91bnRcbiAqIHBlcmlvZGljIHBheW1lbnRzIGFuZCBhIGNvbnN0YW50IGludGVyZXN0IHJhdGUuXG4gKlxuICogQHBhcmFtIHJhdGUgLSBSYXRlIG9mIGludGVyZXN0IChwZXIgcGVyaW9kKVxuICogQHBhcmFtIG5wZXIgLSBOdW1iZXIgb2YgY29tcG91bmRpbmcgcGVyaW9kc1xuICogQHBhcmFtIHBtdCAtIFBheW1lbnRcbiAqIEBwYXJhbSBmdiAtIEZ1dHVyZSB2YWx1ZVxuICogQHBhcmFtIHdoZW4gLSBXaGVuIHBheW1lbnRzIGFyZSBkdWVcbiAqXG4gKiBAcmV0dXJucyB0aGUgcHJlc2VudCB2YWx1ZSBvZiBhIHBheW1lbnQgb3IgaW52ZXN0bWVudFxuICpcbiAqIEBzaW5jZSB2MC4wLjE1XG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBXaGF0IGlzIHRoZSBwcmVzZW50IHZhbHVlIChlLmcuLCB0aGUgaW5pdGlhbCBpbnZlc3RtZW50KVxuICogb2YgYW4gaW52ZXN0bWVudCB0aGF0IG5lZWRzIHRvIHRvdGFsICQxNTY5Mi45M1xuICogYWZ0ZXIgMTAgeWVhcnMgb2Ygc2F2aW5nICQxMDAgZXZlcnkgbW9udGg/ICBBc3N1bWUgdGhlXG4gKiBpbnRlcmVzdCByYXRlIGlzIDUlIChhbm51YWxseSkgY29tcG91bmRlZCBtb250aGx5LlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IHB2IH0gZnJvbSAnZmluYW5jaWFsJ1xuICpcbiAqIHB2KDAuMDUvMTIsIDEwKjEyLCAtMTAwLCAxNTY5Mi45MykgLy8gLTEwMC4wMDA2NzEzMTYyNTgxOVxuICogYGBgXG4gKlxuICogQnkgY29udmVudGlvbiwgdGhlIG5lZ2F0aXZlIHNpZ24gcmVwcmVzZW50cyBjYXNoIGZsb3cgb3V0XG4gKiAoaS5lLiwgbW9uZXkgbm90IGF2YWlsYWJsZSB0b2RheSkuICBUaHVzLCB0byBlbmQgdXAgd2l0aFxuICogJDE1LDY5Mi45MyBpbiAxMCB5ZWFycyBzYXZpbmcgJDEwMCBhIG1vbnRoIGF0IDUlIGFubnVhbFxuICogaW50ZXJlc3QsIG9uZSdzIGluaXRpYWwgZGVwb3NpdCBzaG91bGQgYWxzbyBiZSAkMTAwLlxuICpcbiAqICMjIE5vdGVzXG4gKlxuICogVGhlIHByZXNlbnQgdmFsdWUgaXMgY29tcHV0ZWQgYnkgc29sdmluZyB0aGUgZXF1YXRpb246XG4gKlxuICogYGBgXG4gKiBmdiArIHB2ICogKDEgKyByYXRlKSAqKiBucGVyICsgcG10ICogKDEgKyByYXRlICogd2hlbikgLyByYXRlICogKCgxICsgcmF0ZSkgKiogbnBlciAtIDEpID0gMFxuICogYGBgXG4gKlxuICogb3IsIHdoZW4gYHJhdGUgPSAwYDpcbiAqXG4gKiBgYGBcbiAqIGZ2ICsgcHYgKyBwbXQgKiBucGVyID0gMFxuICogYGBgXG4gKlxuICogZm9yIGBwdmAsIHdoaWNoIGlzIHRoZW4gcmV0dXJuZWQuXG4gKlxuICogIyMgUmVmZXJlbmNlc1xuICpcbiAqIFtXaGVlbGVyLCBELiBBLiwgRS4gUmF0aGtlLCBhbmQgUi4gV2VpciAoRWRzLikgKDIwMDksIE1heSldKGh0dHA6Ly93d3cub2FzaXMtb3Blbi5vcmcvY29tbWl0dGVlcy9kb2N1bWVudHMucGhwP3dnX2FiYnJldj1vZmZpY2UtZm9ybXVsYU9wZW5Eb2N1bWVudC1mb3JtdWxhLTIwMDkwNTA4Lm9kdCkuXG4gKi9cbmZ1bmN0aW9uIHB2KHJhdGUsIG5wZXIsIHBtdCwgZnYsIHdoZW4pIHtcbiAgaWYgKGZ2ID09PSB2b2lkIDApIHtcbiAgICBmdiA9IDA7XG4gIH1cbiAgaWYgKHdoZW4gPT09IHZvaWQgMCkge1xuICAgIHdoZW4gPSBQYXltZW50RHVlVGltZS5FbmQ7XG4gIH1cbiAgdmFyIHdoZW5NdWx0ID0gd2hlbiA9PT0gUGF5bWVudER1ZVRpbWUuQmVnaW4gPyAxIDogMDtcbiAgdmFyIGlzUmF0ZVplcm8gPSByYXRlID09PSAwO1xuICB2YXIgdGVtcCA9IE1hdGgucG93KDEgKyByYXRlLCBucGVyKTtcbiAgdmFyIGZhY3QgPSBpc1JhdGVaZXJvID8gbnBlciA6ICgxICsgcmF0ZSAqIHdoZW5NdWx0KSAqICh0ZW1wIC0gMSkgLyByYXRlO1xuICByZXR1cm4gLShmdiArIHBtdCAqIGZhY3QpIC8gdGVtcDtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgcmF0ZSBvZiBpbnRlcmVzdCBwZXIgcGVyaW9kXG4gKlxuICogQHBhcmFtIG5wZXIgLSBOdW1iZXIgb2YgY29tcG91bmRpbmcgcGVyaW9kc1xuICogQHBhcmFtIHBtdCAtIFBheW1lbnRcbiAqIEBwYXJhbSBwdiAtIFByZXNlbnQgdmFsdWVcbiAqIEBwYXJhbSBmdiAtIEZ1dHVyZSB2YWx1ZVxuICogQHBhcmFtIHdoZW4gLSBXaGVuIHBheW1lbnRzIGFyZSBkdWUgKCdiZWdpbicgb3IgJ2VuZCcpXG4gKiBAcGFyYW0gZ3Vlc3MgLSBTdGFydGluZyBndWVzcyBmb3Igc29sdmluZyB0aGUgcmF0ZSBvZiBpbnRlcmVzdFxuICogQHBhcmFtIHRvbCAtIFJlcXVpcmVkIHRvbGVyYW5jZSBmb3IgdGhlIHNvbHV0aW9uXG4gKiBAcGFyYW0gbWF4SXRlciAtIE1heGltdW0gaXRlcmF0aW9ucyBpbiBmaW5kaW5nIHRoZSBzb2x1dGlvblxuICpcbiAqIEByZXR1cm5zIHRoZSByYXRlIG9mIGludGVyZXN0IHBlciBwZXJpb2QgKG9yIGBOYU5gIGlmIGl0IGNvdWxkXG4gKiAgbm90IGJlIGNvbXB1dGVkIHdpdGhpbiB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgcHJvdmlkZWQpXG4gKlxuICogQHNpbmNlIHYwLjAuMTZcbiAqXG4gKiAjIyBOb3Rlc1xuICpcbiAqIFVzZSBOZXd0b24ncyBpdGVyYXRpb24gdW50aWwgdGhlIGNoYW5nZSBpcyBsZXNzIHRoYW4gMWUtNlxuICogZm9yIGFsbCB2YWx1ZXMgb3IgYSBtYXhpbXVtIG9mIDEwMCBpdGVyYXRpb25zIGlzIHJlYWNoZWQuXG4gKiBOZXd0b24ncyBydWxlIGlzOlxuICpcbiAqIGBgYFxuICogcl97bisxfSA9IHJfe259IC0gZyhyX24pL2cnKHJfbilcbiAqIGBgYFxuICpcbiAqIHdoZXJlOlxuICpcbiAqIC0gYGcocilgIGlzIHRoZSBmb3JtdWxhXG4gKiAtIGBnJyhyKWAgaXMgdGhlIGRlcml2YXRpdmUgd2l0aCByZXNwZWN0IHRvIHIuXG4gKlxuICpcbiAqIFRoZSByYXRlIG9mIGludGVyZXN0IGlzIGNvbXB1dGVkIGJ5IGl0ZXJhdGl2ZWx5IHNvbHZpbmcgdGhlXG4gKiAobm9uLWxpbmVhcikgZXF1YXRpb246XG4gKlxuICogYGBgXG4gKiBmdiArIHB2ICogKDErcmF0ZSkgKiogbnBlciArIHBtdCAqICgxK3JhdGUgKiB3aGVuKSAvIHJhdGUgKiAoKDErcmF0ZSkgKiogbnBlciAtIDEpID0gMFxuICogYGBgXG4gKlxuICogZm9yIGByYXRlLlxuICpcbiAqICMjIFJlZmVyZW5jZXNcbiAqXG4gKiBbV2hlZWxlciwgRC4gQS4sIEUuIFJhdGhrZSwgYW5kIFIuIFdlaXIgKEVkcy4pICgyMDA5LCBNYXkpXShodHRwOi8vd3d3Lm9hc2lzLW9wZW4ub3JnL2NvbW1pdHRlZXMvZG9jdW1lbnRzLnBocD93Z19hYmJyZXY9b2ZmaWNlLWZvcm11bGFPcGVuRG9jdW1lbnQtZm9ybXVsYS0yMDA5MDUwOC5vZHQpLlxuICovXG5mdW5jdGlvbiByYXRlKG5wZXIsIHBtdCwgcHYsIGZ2LCB3aGVuLCBndWVzcywgdG9sLCBtYXhJdGVyKSB7XG4gIGlmICh3aGVuID09PSB2b2lkIDApIHtcbiAgICB3aGVuID0gUGF5bWVudER1ZVRpbWUuRW5kO1xuICB9XG4gIGlmIChndWVzcyA9PT0gdm9pZCAwKSB7XG4gICAgZ3Vlc3MgPSAwLjE7XG4gIH1cbiAgaWYgKHRvbCA9PT0gdm9pZCAwKSB7XG4gICAgdG9sID0gMWUtNjtcbiAgfVxuICBpZiAobWF4SXRlciA9PT0gdm9pZCAwKSB7XG4gICAgbWF4SXRlciA9IDEwMDtcbiAgfVxuICB2YXIgcm4gPSBndWVzcztcbiAgdmFyIGl0ZXJhdG9yID0gMDtcbiAgdmFyIGNsb3NlID0gZmFsc2U7XG4gIHdoaWxlIChpdGVyYXRvciA8IG1heEl0ZXIgJiYgIWNsb3NlKSB7XG4gICAgdmFyIHJucDEgPSBybiAtIF9nRGl2R3Aocm4sIG5wZXIsIHBtdCwgcHYsIGZ2LCB3aGVuKTtcbiAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHJucDEgLSBybik7XG4gICAgY2xvc2UgPSBkaWZmIDwgdG9sO1xuICAgIGl0ZXJhdG9yKys7XG4gICAgcm4gPSBybnAxO1xuICB9XG4gIC8vIGlmIGV4YXVzdGVkIGFsbCB0aGUgaXRlcmF0aW9ucyBhbmQgdGhlIHJlc3VsdCBpcyBub3RcbiAgLy8gY2xvc2UgZW5vdWdoLCByZXR1cm5zIGBOYU5gXG4gIGlmICghY2xvc2UpIHtcbiAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgfVxuICByZXR1cm4gcm47XG59XG4vKipcbiAqIFJldHVybiB0aGUgSW50ZXJuYWwgUmF0ZSBvZiBSZXR1cm4gKElSUikuXG4gKlxuICogVGhpcyBpcyB0aGUgXCJhdmVyYWdlXCIgcGVyaW9kaWNhbGx5IGNvbXBvdW5kZWQgcmF0ZSBvZiByZXR1cm5cbiAqIHRoYXQgZ2l2ZXMgYSBuZXQgcHJlc2VudCB2YWx1ZSBvZiAwLjA7IGZvciBhIG1vcmUgY29tcGxldGVcbiAqIGV4cGxhbmF0aW9uLCBzZWUgTm90ZXMgYmVsb3cuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIElucHV0IGNhc2ggZmxvd3MgcGVyIHRpbWUgcGVyaW9kLlxuICogICBCeSBjb252ZW50aW9uLCBuZXQgXCJkZXBvc2l0c1wiXG4gKiAgIGFyZSBuZWdhdGl2ZSBhbmQgbmV0IFwid2l0aGRyYXdhbHNcIiBhcmUgcG9zaXRpdmUuICBUaHVzLCBmb3JcbiAqICAgZXhhbXBsZSwgYXQgbGVhc3QgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYHZhbHVlc2AsIHdoaWNoIHJlcHJlc2VudHNcbiAqICAgdGhlIGluaXRpYWwgaW52ZXN0bWVudCwgd2lsbCB0eXBpY2FsbHkgYmUgbmVnYXRpdmUuXG4gKiBAcGFyYW0gZ3Vlc3MgLSBTdGFydGluZyBndWVzcyBmb3Igc29sdmluZyB0aGUgSW50ZXJuYWwgUmF0ZSBvZiBSZXR1cm5cbiAqIEBwYXJhbSB0b2wgLSBSZXF1aXJlZCB0b2xlcmFuY2UgZm9yIHRoZSBzb2x1dGlvblxuICogQHBhcmFtIG1heEl0ZXIgLSBNYXhpbXVtIGl0ZXJhdGlvbnMgaW4gZmluZGluZyB0aGUgc29sdXRpb25cbiAqXG4gKiBAcmV0dXJucyBJbnRlcm5hbCBSYXRlIG9mIFJldHVybiBmb3IgcGVyaW9kaWMgaW5wdXQgdmFsdWVzXG4gKlxuICogQHNpbmNlIHYwLjAuMTdcbiAqXG4gKiAjIyBOb3Rlc1xuICpcbiAqIFRoZSBJUlIgaXMgcGVyaGFwcyBiZXN0IHVuZGVyc3Rvb2QgdGhyb3VnaCBhbiBleGFtcGxlIChpbGx1c3RyYXRlZFxuICogdXNpbmcgYGlycmAgaW4gdGhlIEV4YW1wbGVzIHNlY3Rpb24gYmVsb3cpLlxuICpcbiAqIFN1cHBvc2Ugb25lIGludmVzdHMgMTAwXG4gKiB1bml0cyBhbmQgdGhlbiBtYWtlcyB0aGUgZm9sbG93aW5nIHdpdGhkcmF3YWxzIGF0IHJlZ3VsYXIgKGZpeGVkKVxuICogaW50ZXJ2YWxzOiAzOSwgNTksIDU1LCAyMC4gIEFzc3VtaW5nIHRoZSBlbmRpbmcgdmFsdWUgaXMgMCwgb25lJ3MgMTAwXG4gKiB1bml0IGludmVzdG1lbnQgeWllbGRzIDE3MyB1bml0czsgaG93ZXZlciwgZHVlIHRvIHRoZSBjb21iaW5hdGlvbiBvZlxuICogY29tcG91bmRpbmcgYW5kIHRoZSBwZXJpb2RpYyB3aXRoZHJhd2FscywgdGhlIFwiYXZlcmFnZVwiIHJhdGUgb2YgcmV0dXJuXG4gKiBpcyBuZWl0aGVyIHNpbXBseSAwLjczLzQgbm9yICgxLjczKV4wLjI1LTEuXG4gKiBSYXRoZXIsIGl0IGlzIHRoZSBzb2x1dGlvbiAoZm9yIGByYCkgb2YgdGhlIGVxdWF0aW9uOlxuICpcbiAqIGBgYFxuICogLTEwMCArIDM5LygxK3IpICsgNTkvKCgxK3IpXjIpICsgNTUvKCgxK3IpXjMpICsgMjAvKCgxK3IpXjQpID0gMFxuICogYGBgXG4gKlxuICogSW4gZ2VuZXJhbCwgZm9yIGB2YWx1ZXNgID0gYFswLCAxLCAuLi4gTV1gLFxuICogYGlycmAgaXMgdGhlIHNvbHV0aW9uIG9mIHRoZSBlcXVhdGlvbjpcbiAqXG4gKiBgYGBcbiAqIFxcXFxzdW1fe3Q9MH1eTXtcXFxcZnJhY3t2X3R9eygxK2lycilee3R9fX0gPSAwXG4gKiBgYGBcbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgaXJyIH0gZnJvbSAnZmluYW5jaWFsJ1xuICpcbiAqIGlycihbLTEwMCwgMzksIDU5LCA1NSwgMjBdKSAvLyAwLjI4MDk1XG4gKiBpcnIoWy0xMDAsIDAsIDAsIDc0XSkgLy8gLTAuMDk1NVxuICogaXJyKFstMTAwLCAxMDAsIDAsIC03XSkgLy8gLTAuMDgzM1xuICogaXJyKFstMTAwLCAxMDAsIDAsIDddKSAvLyAwLjA2MjA2XG4gKiBpcnIoWy01LCAxMC41LCAxLCAtOCwgMV0pIC8vIDAuMDg4NlxuICogYGBgXG4gKlxuICogIyMgUmVmZXJlbmNlc1xuICpcbiAqIC0gTC4gSi4gR2l0bWFuLCBcIlByaW5jaXBsZXMgb2YgTWFuYWdlcmlhbCBGaW5hbmNlLCBCcmllZixcIiAzcmQgZWQuLFxuICogIEFkZGlzb24tV2VzbGV5LCAyMDAzLCBwZy4gMzQ4LlxuICovXG5mdW5jdGlvbiBpcnIodmFsdWVzLCBndWVzcywgdG9sLCBtYXhJdGVyKSB7XG4gIGlmIChndWVzcyA9PT0gdm9pZCAwKSB7XG4gICAgZ3Vlc3MgPSAwLjE7XG4gIH1cbiAgaWYgKHRvbCA9PT0gdm9pZCAwKSB7XG4gICAgdG9sID0gMWUtNjtcbiAgfVxuICBpZiAobWF4SXRlciA9PT0gdm9pZCAwKSB7XG4gICAgbWF4SXRlciA9IDEwMDtcbiAgfVxuICAvLyBCYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9naGFsaW1pLzQ1OTEzMzggYnkgQGdoYWxpbWlcbiAgLy8gQVNGIGxpY2Vuc2VkIChjaGVjayB0aGUgbGluayBmb3IgdGhlIGZ1bGwgbGljZW5zZSlcbiAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG4gIC8vIEluaXRpYWxpemUgZGF0ZXMgYW5kIGNoZWNrIHRoYXQgdmFsdWVzIGNvbnRhaW5zIGF0XG4gIC8vIGxlYXN0IG9uZSBwb3NpdGl2ZSB2YWx1ZSBhbmQgb25lIG5lZ2F0aXZlIHZhbHVlXG4gIHZhciBkYXRlcyA9IFtdO1xuICB2YXIgcG9zaXRpdmUgPSBmYWxzZTtcbiAgdmFyIG5lZ2F0aXZlID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0ZXNbaV0gPSBpID09PSAwID8gMCA6IGRhdGVzW2kgLSAxXSArIDM2NTtcbiAgICBpZiAodmFsdWVzW2ldID4gMCkge1xuICAgICAgcG9zaXRpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWVzW2ldIDwgMCkge1xuICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBSZXR1cm4gZXJyb3IgaWYgdmFsdWVzIGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHBvc2l0aXZlXG4gIC8vIHZhbHVlIGFuZCBvbmUgbmVnYXRpdmUgdmFsdWVcbiAgaWYgKCFwb3NpdGl2ZSB8fCAhbmVnYXRpdmUpIHtcbiAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgfVxuICAvLyBJbml0aWFsaXplIGd1ZXNzIGFuZCByZXN1bHRSYXRlXG4gIHZhciByZXN1bHRSYXRlID0gZ3Vlc3M7XG4gIC8vIEltcGxlbWVudCBOZXd0b24ncyBtZXRob2RcbiAgdmFyIG5ld1JhdGUgPSAwO1xuICB2YXIgZXBzUmF0ZSA9IDA7XG4gIHZhciByZXN1bHRWYWx1ZSA9IDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB2YXIgY29udExvb3AgPSB0cnVlO1xuICBkbyB7XG4gICAgcmVzdWx0VmFsdWUgPSBfaXJyUmVzdWx0KHZhbHVlcywgZGF0ZXMsIHJlc3VsdFJhdGUpO1xuICAgIG5ld1JhdGUgPSByZXN1bHRSYXRlIC0gcmVzdWx0VmFsdWUgLyBfaXJyUmVzdWx0RGVyaXYodmFsdWVzLCBkYXRlcywgcmVzdWx0UmF0ZSk7XG4gICAgZXBzUmF0ZSA9IE1hdGguYWJzKG5ld1JhdGUgLSByZXN1bHRSYXRlKTtcbiAgICByZXN1bHRSYXRlID0gbmV3UmF0ZTtcbiAgICBjb250TG9vcCA9IGVwc1JhdGUgPiB0b2wgJiYgTWF0aC5hYnMocmVzdWx0VmFsdWUpID4gdG9sO1xuICB9IHdoaWxlIChjb250TG9vcCAmJiArK2l0ZXJhdGlvbiA8IG1heEl0ZXIpO1xuICBpZiAoY29udExvb3ApIHtcbiAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgfVxuICAvLyBSZXR1cm4gaW50ZXJuYWwgcmF0ZSBvZiByZXR1cm5cbiAgcmV0dXJuIHJlc3VsdFJhdGU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIE5QViAoTmV0IFByZXNlbnQgVmFsdWUpIG9mIGEgY2FzaCBmbG93IHNlcmllcy5cbiAqXG4gKiBAcGFyYW0gcmF0ZSAtIFRoZSBkaXNjb3VudCByYXRlXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyBvZiB0aGUgdGltZSBzZXJpZXMgb2YgY2FzaCBmbG93cy4gIFRoZSAoZml4ZWQpIHRpbWVcbiAqIGludGVydmFsIGJldHdlZW4gY2FzaCBmbG93IFwiZXZlbnRzXCIgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGF0IGZvclxuICogd2hpY2ggYHJhdGVgIGlzIGdpdmVuIChpLmUuLCBpZiBgcmF0ZWAgaXMgcGVyIHllYXIsIHRoZW4gcHJlY2lzZWx5XG4gKiBhIHllYXIgaXMgdW5kZXJzdG9vZCB0byBlbGFwc2UgYmV0d2VlbiBlYWNoIGNhc2ggZmxvdyBldmVudCkuICBCeVxuICogY29udmVudGlvbiwgaW52ZXN0bWVudHMgb3IgXCJkZXBvc2l0c1wiIGFyZSBuZWdhdGl2ZSwgaW5jb21lIG9yXG4gKiBcIndpdGhkcmF3YWxzXCIgYXJlIHBvc2l0aXZlOyBgdmFsdWVzYCBtdXN0IGJlZ2luIHdpdGggdGhlIGluaXRpYWxcbiAqIGludmVzdG1lbnQsIHRodXMgYHZhbHVlc1swXWAgd2lsbCB0eXBpY2FsbHkgYmUgbmVnYXRpdmUuXG4gKiBAcmV0dXJucyBUaGUgTlBWIG9mIHRoZSBpbnB1dCBjYXNoIGZsb3cgc2VyaWVzIGB2YWx1ZXNgIGF0IHRoZSBkaXNjb3VudCBgcmF0ZWAuXG4gKlxuICogQHNpbmNlIHYwLjAuMThcbiAqXG4gKiAjIyBXYXJuaW5nc1xuICpcbiAqIGBucHYgY29uc2lkZXJzIGEgc2VyaWVzIG9mIGNhc2hmbG93cyBzdGFydGluZyBpbiB0aGUgcHJlc2VudCAodCA9IDApLlxuICogTlBWIGNhbiBhbHNvIGJlIGRlZmluZWQgd2l0aCBhIHNlcmllcyBvZiBmdXR1cmUgY2FzaGZsb3dzLCBwYWlkIGF0IHRoZVxuICogZW5kLCByYXRoZXIgdGhhbiB0aGUgc3RhcnQsIG9mIGVhY2ggcGVyaW9kLiBJZiBmdXR1cmUgY2FzaGZsb3dzIGFyZSB1c2VkLFxuICogdGhlIGZpcnN0IGNhc2hmbG93IGB2YWx1ZXNbMF1gIG11c3QgYmUgemVyb2VkIGFuZCBhZGRlZCB0byB0aGUgbmV0XG4gKiBwcmVzZW50IHZhbHVlIG9mIHRoZSBmdXR1cmUgY2FzaGZsb3dzLiBUaGlzIGlzIGRlbW9uc3RyYXRlZCBpbiB0aGVcbiAqIGV4YW1wbGVzLlxuICpcbiAqICMjIE5vdGVzXG4gKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mOlxuICpcbiAqIGBgYFxuICogXFxcXHN1bV97dD0wfV57TS0xfXtcXFxcZnJhY3t2YWx1ZXNfdH17KDErcmF0ZSlee3R9fX1cbiAqIGBgYFxuICpcbiAqICMjIEV4YW1wbGVzXG4gKlxuICogQ29uc2lkZXIgYSBwb3RlbnRpYWwgcHJvamVjdCB3aXRoIGFuIGluaXRpYWwgaW52ZXN0bWVudCBvZiAkNDAgMDAwIGFuZFxuICogcHJvamVjdGVkIGNhc2hmbG93cyBvZiAkNSAwMDAsICQ4IDAwMCwgJDEyIDAwMCBhbmQgJDMwIDAwMCBhdCB0aGUgZW5kIG9mXG4gKiBlYWNoIHBlcmlvZCBkaXNjb3VudGVkIGF0IGEgcmF0ZSBvZiA4JSBwZXIgcGVyaW9kLiBUbyBmaW5kIHRoZSBwcm9qZWN0J3NcbiAqIG5ldCBwcmVzZW50IHZhbHVlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7bnB2fSBmcm9tICdmaW5hbmNpYWwnXG4gKlxuICogY29uc3QgcmF0ZSA9IDAuMDhcbiAqIGNvbnN0IGNhc2hmbG93cyA9IFstNDBfMDAwLCA1MDAwLCA4MDAwLCAxMjAwMCwgMzAwMDBdXG4gKiBucHYocmF0ZSwgY2FzaGZsb3dzKSAvLyAzMDY1LjIyMjY2ODE3OTUyNTVcbiAqIGBgYFxuICpcbiAqIEl0IG1heSBiZSBwcmVmZXJhYmxlIHRvIHNwbGl0IHRoZSBwcm9qZWN0ZWQgY2FzaGZsb3cgaW50byBhbiBpbml0aWFsXG4gKiBpbnZlc3RtZW50IGFuZCBleHBlY3RlZCBmdXR1cmUgY2FzaGZsb3dzLiBJbiB0aGlzIGNhc2UsIHRoZSB2YWx1ZSBvZlxuICogdGhlIGluaXRpYWwgY2FzaGZsb3cgaXMgemVybyBhbmQgdGhlIGluaXRpYWwgaW52ZXN0bWVudCBpcyBsYXRlciBhZGRlZFxuICogdG8gdGhlIGZ1dHVyZSBjYXNoZmxvd3MgbmV0IHByZXNlbnQgdmFsdWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgaW5pdGlhbENhc2hmbG93ID0gY2FzaGZsb3dzWzBdXG4gKiBjYXNoZmxvd3NbMF0gPSAwXG4gKlxuICogbnB2KHJhdGUsIGNhc2hmbG93cykgKyBpbml0aWFsQ2FzaGZsb3cgLy8gMzA2NS4yMjI2NjgxNzk1MjU1XG4gKiBgYGBcbiAqXG4gKiAjIyBSZWZlcmVuY2VzXG4gKlxuICogTC4gSi4gR2l0bWFuLCBcIlByaW5jaXBsZXMgb2YgTWFuYWdlcmlhbCBGaW5hbmNlLCBCcmllZixcIlxuICogM3JkIGVkLiwgQWRkaXNvbi1XZXNsZXksIDIwMDMsIHBnLiAzNDYuXG4gKi9cbmZ1bmN0aW9uIG5wdihyYXRlLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyciwgaSkge1xuICAgIHJldHVybiBhY2MgKyBjdXJyIC8gTWF0aC5wb3coMSArIHJhdGUsIGkpO1xuICB9LCAwKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgTW9kaWZpZWQgSW50ZXJuYWwgUmF0ZSBvZiBSZXR1cm4uXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIENhc2ggZmxvd3MgKG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcG9zaXRpdmUgYW5kIG9uZSBuZWdhdGl2ZVxuICogICB2YWx1ZSkgb3IgbmFuIGlzIHJldHVybmVkLiAgVGhlIGZpcnN0IHZhbHVlIGlzIGNvbnNpZGVyZWQgYSBzdW5rXG4gKiAgIGNvc3QgYXQgdGltZSB6ZXJvLlxuICogQHBhcmFtIGZpbmFuY2VSYXRlIC0gSW50ZXJlc3QgcmF0ZSBwYWlkIG9uIHRoZSBjYXNoIGZsb3dzXG4gKiBAcGFyYW0gcmVpbnZlc3RSYXRlIC0gSW50ZXJlc3QgcmF0ZSByZWNlaXZlZCBvbiB0aGUgY2FzaCBmbG93cyB1cG9uIHJlaW52ZXN0bWVudFxuICpcbiAqIEByZXR1cm5zIE1vZGlmaWVkIGludGVybmFsIHJhdGUgb2YgcmV0dXJuXG4gKlxuICogQHNpbmNlIHYwLjEuMFxuICovXG5mdW5jdGlvbiBtaXJyKHZhbHVlcywgZmluYW5jZVJhdGUsIHJlaW52ZXN0UmF0ZSkge1xuICB2YXIgcG9zaXRpdmUgPSBmYWxzZTtcbiAgdmFyIG5lZ2F0aXZlID0gZmFsc2U7XG4gIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodmFsdWVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICB2YXIgdmFsdWUgPSBfc3RlcC52YWx1ZTtcbiAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICBwb3NpdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIG5lZ2F0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gUmV0dXJuIGVycm9yIGlmIHZhbHVlcyBkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZVxuICAvLyBwb3NpdGl2ZSB2YWx1ZSBhbmQgb25lIG5lZ2F0aXZlIHZhbHVlXG4gIGlmICghcG9zaXRpdmUgfHwgIW5lZ2F0aXZlKSB7XG4gICAgcmV0dXJuIE51bWJlci5OYU47XG4gIH1cbiAgdmFyIG51bWVyID0gTWF0aC5hYnMobnB2KHJlaW52ZXN0UmF0ZSwgdmFsdWVzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ID4gMCA/IHggOiAwO1xuICB9KSkpO1xuICB2YXIgZGVub20gPSBNYXRoLmFicyhucHYoZmluYW5jZVJhdGUsIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCA8IDAgPyB4IDogMDtcbiAgfSkpKTtcbiAgcmV0dXJuIE1hdGgucG93KG51bWVyIC8gZGVub20sIDEgLyAodmFsdWVzLmxlbmd0aCAtIDEpKSAqICgxICsgcmVpbnZlc3RSYXRlKSAtIDE7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSB0byBzaW1wbHkgaGF2ZSBhIGRpZmZlcmVudCBuYW1lIGZvciB0aGUgJ2Z2J1xuICogZnVuY3Rpb24gdG8gbm90IGludGVyZmVyZSB3aXRoIHRoZSAnZnYnIGtleXdvcmQgYXJndW1lbnQgd2l0aGluIHRoZSAnaXBtdCdcbiAqIGZ1bmN0aW9uLiAgSXQgaXMgdGhlICdyZW1haW5pbmcgYmFsYW5jZSBvbiBsb2FuJyB3aGljaCBtaWdodCBiZSB1c2VmdWwgYXNcbiAqIGl0J3Mgb3duIGZ1bmN0aW9uLCBidXQgaXMgZWFzaWx5IGNhbGN1bGF0ZWQgd2l0aCB0aGUgJ2Z2JyBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmJsKHJhdGUsIHBlciwgcG10LCBwdiwgd2hlbikge1xuICByZXR1cm4gZnYocmF0ZSwgcGVyIC0gMSwgcG10LCBwdiwgd2hlbik7XG59XG4vKipcbiAqIEV2YWx1YXRlcyBgZyhyX24pL2cnKHJfbilgLCB3aGVyZTpcbiAqXG4gKiBgYGBcbiAqIGcgPSBmdiArIHB2ICogKDErcmF0ZSkgKiogbnBlciArIHBtdCAqICgxK3JhdGUgKiB3aGVuKS9yYXRlICogKCgxK3JhdGUpICoqIG5wZXIgLSAxKVxuICogYGBgXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dEaXZHcChyLCBuLCBwLCB4LCB5LCB3aGVuKSB7XG4gIHZhciB3ID0gd2hlbiA9PT0gUGF5bWVudER1ZVRpbWUuQmVnaW4gPyAxIDogMDtcbiAgdmFyIHQxID0gTWF0aC5wb3cociArIDEsIG4pO1xuICB2YXIgdDIgPSBNYXRoLnBvdyhyICsgMSwgbiAtIDEpO1xuICB2YXIgZyA9IHkgKyB0MSAqIHggKyBwICogKHQxIC0gMSkgKiAociAqIHcgKyAxKSAvIHI7XG4gIHZhciBncCA9IG4gKiB0MiAqIHggLSBwICogKHQxIC0gMSkgKiAociAqIHcgKyAxKSAvIE1hdGgucG93KHIsIDIpICsgbiAqIHAgKiB0MiAqIChyICogdyArIDEpIC8gciArIHAgKiAodDEgLSAxKSAqIHcgLyByO1xuICByZXR1cm4gZyAvIGdwO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSByZXN1bHRpbmcgYW1vdW50LlxuICpcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2doYWxpbWkvNDU5MTMzOCBieSBAZ2hhbGltaVxuICogQVNGIGxpY2Vuc2VkIChjaGVjayB0aGUgbGluayBmb3IgdGhlIGZ1bGwgbGljZW5zZSlcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXJyUmVzdWx0KHZhbHVlcywgZGF0ZXMsIHJhdGUpIHtcbiAgdmFyIHIgPSByYXRlICsgMTtcbiAgdmFyIHJlc3VsdCA9IHZhbHVlc1swXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gdmFsdWVzW2ldIC8gTWF0aC5wb3cociwgKGRhdGVzW2ldIC0gZGF0ZXNbMF0pIC8gMzY1KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBmaXJzdCBkZXJpdmF0aW9uXG4gKlxuICogQmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2hhbGltaS80NTkxMzM4IGJ5IEBnaGFsaW1pXG4gKiBBU0YgbGljZW5zZWQgKGNoZWNrIHRoZSBsaW5rIGZvciB0aGUgZnVsbCBsaWNlbnNlKVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pcnJSZXN1bHREZXJpdih2YWx1ZXMsIGRhdGVzLCByYXRlKSB7XG4gIHZhciByID0gcmF0ZSArIDE7XG4gIHZhciByZXN1bHQgPSAwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmcmFjID0gKGRhdGVzW2ldIC0gZGF0ZXNbMF0pIC8gMzY1O1xuICAgIHJlc3VsdCAtPSBmcmFjICogdmFsdWVzW2ldIC8gTWF0aC5wb3cociwgZnJhYyArIDEpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IFBheW1lbnREdWVUaW1lLCBmdiwgaXBtdCwgaXJyLCBtaXJyLCBucGVyLCBucHYsIHBtdCwgcHBtdCwgcHYsIHJhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmFuY2lhbC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/financial/dist/financial.esm.js\n");

/***/ })

};
;